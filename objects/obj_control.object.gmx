<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_font(f_Default);

randomize();

state = "initializing";

turnOrder = ds_list_create();
 
turnCounter = -1;
 
turnMax =  0;
 
currentActor = noone;
 
roundCounter = 0;

globalvar map;

mapWidth = room_width/GRID_SIZE;
mapHeight = room_height/GRID_SIZE;

//Create node
for(i =0; i &lt; mapWidth; i++){
    for(j = 0; j &lt; mapHeight; j++){
        map[i,j] = instance_create(i * GRID_SIZE,j * GRID_SIZE, obj_Node);
        map[i, j].gridX = i;
        map[i, j].gridY = j;
    }
}

//Populate neighbor lists
for(i =0; i &lt; mapWidth; i++){
    for(j = 0; j &lt; mapHeight; j++){
        node = map[i,j];
        
        //Add left neighbor
        if(i &gt; 0){
            ds_list_add(node.neighbors, map[i-1,j]);
        }
        
         //Add right neighbor
        if(i &lt; mapWidth - 1){
            ds_list_add(node.neighbors, map[i+1,j]);
        }
        
         //Add top neighbor
        if(j &gt; 0){
            ds_list_add(node.neighbors, map[i,j-1]);
        }
        
         //Add bottom neighbor
        if(j &lt; mapHeight - 1){
            ds_list_add(node.neighbors, map[i,j+1]);
        }
        
        //Top left neighbor
        if(i &gt; 0 &amp;&amp; j &gt; 0){
            ds_list_add(node.neighbors, map[i - 1, j - 1]);
        }
        
        //Top right neighbor
        if(i &lt; mapWidth - 1 &amp;&amp; j &gt; 0){
            ds_list_add(node.neighbors, map[i + 1, j - 1]);
        }
        
        //Bottom left neighbor
        if(i &gt; 0 &amp;&amp; j &lt; mapHeight - 1){
            ds_list_add(node.neighbors, map[i - 1, j + 1]);
        }
        
        //Bottom right neighbor
        if(i &lt; mapWidth - 1 &amp;&amp; j &lt; mapHeight - 1){
            ds_list_add(node.neighbors, map[i + 1, j + 1]);
        }
        
    }
}

instance_create(x, y, obj_cursor);



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(state){
    
case "initializing":
    with(obj_Node){
        if(instance_position(x + 32, y +32, obj_terrain)){
          tempTerrain = instance_position(x + 32, y +32, obj_terrain);
    
            switch(tempTerrain.type){
                case "wall":
                 instance_change(obj_wall, true);
                 type = "wall";
                 passable = false;
              
                 break;
            
                case "tree":
                instance_change(obj_treeSpace, true);
                type = "tree";
                cost = 2;
            
                break;
    
            }
    
                with(tempTerrain){
                     instance_destroy();
             }
       } 
       
       if(instance_position(x + 32, y + 32, obj_actor)){
        occupant = instance_position(x + 32, y + 32, obj_actor);
        occupant.gridX = gridX;
        occupant.gridY = gridY;
        }
}

    state = "roll init";
    break;

    case "roll init":
        tempInit = ds_priority_create();
       with(obj_actor){
            initRoll = irandom_range(1, 20) + initiative;
            
            ds_priority_add(other.tempInit, id, initRoll);
            }
            
       while(ds_priority_size(tempInit) &gt; 0){
          ds_list_add(turnOrder, ds_priority_delete_max(tempInit));
            }
 
    turnMax = ds_list_size(turnOrder);
 
   ds_priority_destroy(tempInit);
    
    state = "ready";
    break;
 
    case "ready":
       if(currentActor == noone){
            turnCounter += 1;

          if(turnCounter &gt;= turnMax){
                turnCounter = 0;
                roundCounter += 1; 
          }
 
            currentActor = ds_list_find_value(turnOrder, turnCounter);
            
            currentActor.actions= 2;
            currentActor.canAct = true;
            
            //only pass off actions and cursor control if actor is BLUE_ARMY
            //otherwise set flash variable to true and set alarm
            if(currentActor.army == BLUE_ARMY){
                obj_cursor.selectedActor = currentActor;
     
                movement_range(map[currentActor.gridX, currentActor.gridY], currentActor.move, currentActor.actions);
                
                switch(currentActor.attackType){
                    case "ranged":
                        ranged_attack_range(currentActor);
                        break;
                        
                    case "melee":
                        melee_attack_range(currentActor);
                        break;
                }
                
            }else{
                currentActor.flash = true;
                currentActor.alarm[0] = 30;
                
            }
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
